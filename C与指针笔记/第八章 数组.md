8.1 一维数组
  数组名在使用时是一个指针常量，不是变量，数组不同于指针具有确定数量的元素，只有两种情况数组名不再作为指针常量来表示——就是当数组名作为sizeof操作符或单目操作符&的操作数时。sizeof返回整个数组的长度，而不是指向数组的指针的长度，取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量值的指针（&a[0]表示数组a的首地址，与a作用相同)。数组名不能被赋值！
8.1.2 下标引用
  除了优先级之外，下标引用和间接访问完全相同：array[subscript]和*(array + (subscript))完全相同。
  下标为负值，转换为间接访问表达式。当然数组首地址前面的访问是有问题的。
  下标超过元素总数也是有问题的。
  正是因为指针的间接访问和下标相同，而且指针也可以使用下标，所以C对下标的有效性检查开销更大，所以没有下标检查。
  注：array若是数组名，2[array]和array[2]作用相同，由间接访问计算。
8.1.3 指针与下标
  指针和下标表达式是可以互换的，有时指针比下标更有效率，反之不能。
  存在指针类型在指针自增时，不是单纯加1，而要和数据类型占字节数相乘再相加，若是下标，每次都要乘下标，若是指针自增，每次都是1×字节数，这个值可以在编译器优化成一条指令，只乘一次，以后不用乘法，只用加法。
8.1.4 指针的效率
  1、当你根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1而且机器具有地址自动增量模型时，这点表现得更为突出。
  2、声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高（具体提高的幅度取决于你所使用的机器）。
  3、如果你可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，那么你就不需要使用一个单独的计数器。
  4、那些必须在运行时求值的表达式较之诸如&array[SIZE]或array+SIZE这样的常量表达式往往代价更高。
8.1.5 数组与指针
  声明数组时，编译器将根据声明所指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。
  声明一个指针变量，编译器只为指针本身保留内存空间。
8.1.6 作为函数参数的数组名
  此时传递给函数的是一份该指针（数组名）的拷贝。可以对指针所指向位置读取和修改，但不会影响原数组名（指针）的值。
  如果不想修改传入的指针，可以声明为const类型。
8.1.7 声明数组参数
  声明为指针变量或数组形式的形参都可以。但本质都是指针，所以数组中括号里不加大小就是正常的，因为函数并不会分配内存空间给形参。
8.1.8 初始化
  使用一对花括号，每个值中间用逗号分割。
  静态数组会自动初始化为0。自动变量初始化随机。
8.1.9 不完整的初始化
  初始化数量可以少不可以多，只能省略后面不能省略前面。
8.1.10 自动计算数组长度
  如果声明中没给出数组长度，但是初始化列表有，则编译器自动把数组长度设置为列表所容纳的值的个数。
8.1.11 字符数组的初始化
  可以用初始化列表一个一个初始，但也可以更简洁快速的用“字符串常量”初始。之所以用引号，因为实际上这不是一个字符串常量，而是初始化列表的另一种写法。
8.2 多维数组
  理解从不同的视点（view）观察多维数组，2维是第一维个元素，每个元素都是第二维大小的向量……
8.2.1 存储顺序
  数组元素存储顺序按照最右边的下标率先变化的原则，称为行主序。你尽可以将第一维看成列，但是不影响存储顺序，这时按照存储顺序访问元素，所获得的是按行排列的元素。
8.2.2 数组名
  一维数组名的值是一个指针常量，是指向元素类型的指针，多维数组也差不多，唯一区别是多维数组第一维元素实际上是另一个数组，多维数组名的值是一个指向其第二维元素个数个元素数组的指针。
8.2.3 下标
  下标表达式也可以与间接访问互换。
8.2.4 指向数组的指针
  定义指向数组的指针，需要把*括在括号里，表示优先级，然后再括号外加[]中间必须加想指向的数组的长度，如果没有可能在指针加某个整数意图移动整行时，整数的值将根据空数组的长度进行乘法（乘0），就发生错误了。
8.2.5 作为函数参数的多维数组
  传递的是个指向数组第一个元素也就是一个数组的指针。但是第二维及以后各维长度需要告知函数的形参。第一维的长度可以省略。
8.2.6 初始化
  初始化列表按存储顺序写。可以分行用花括号初始化，分行后就可以用不完整的初始化列表分行赋值前面的部分。
8.2.7 数组长度自动计算
  只有第一维长度可以有初始化列表缺省地提供。
8.3 指针数组
  每个元素都是一个指针。

警告总结：
  1、当访问多维数组的元素时，误用逗号分隔下标。
  2、在一个指向未指定要指向数组的长度的指针上执行指针运算。
编程提示：
  1、源代码的可读性几乎总是比程序的运行效率更为重要。
  2、只要有可能，函数的指针形参都应该声明为const
  3、在有些环境，使用register关键字提高程序的运行时效率
  4、在多维数组的初始值列表中使用完整的多层花括号能提高可读性。

问题：
8.一个文件里声明了a是10个整形元素的数组，b是一个指针，虽然初始化为a的首地址。在另一个文件中extern定义了指针变量a，数组b，当a[3]被当作右值使用时，编译器把它当作指针，于是提取这个指针的值然后给这个值加3*4再间接访问，而实际上a是数组，提取值后是数组第一个整数，再加3*4是未知地址了。同样，b[3]被当作a数组首地址加12再间接访问，实际上b是指针变量，b的存储地址并不是数组a首地址。


习题：
5：
void matrix_multiply(int *m1, int *m2, int *r, int x, int y, int z)
{
  /*
  m1是一个x行y列的矩阵，m2是一个y行z列的矩阵。
  矩阵相乘结果存储于r中，它是一个x行z列的矩阵。
  */
  int i,j,k,t=0;
  for (i = 0; i < x; i++) {
    for(k = 0; k < z; k++)
    {
      t=0;
      for(j = 0; j < y; j++){
        t += *(m1+i*y+j) * (*(m2+j*z+k));
      }
      *(r+i*z+k) = t;
    }
  }
}
