第六章 指针
6.1 内存和地址
  内存中每一个位置都由一个独一无二的地址标识。
  内存中的每个位置都包含一个值。
  变量和内存地址之间的关联是由编译器为我们实现的。
6.2 值和类型
  不能简单地通过检查一个值的位来判断它的类型
6.3 指针变量的内容
  &操作符用于产生操作数的内存地址，赋予指针变量。
6.4 间接访问操作符
  通过指针访问它所指向的地址的过程称为间接访问或解引用指针。
  操作符是*。
6.5 未初始化和非法的指针
  未初始化的指针内容不确定，使用间接访问操作符赋值变量是非法的。如果运气好是个非法地址（如负值或未分配给程序的地址），赋值语句会出错，在UNIX系统上，这个错误被称为“段违例”（segmentation violation），或内存错误（memory fault）。如果内容处在错误的边界上，如要求整数必须存储于特定边界上的机器，这种访问会在UNIX系统中被称为“总线错误”（bus error）。
  一个更为严重的情况是：指针修改了一个合法地址处的值
6.6 NULL 指针
  标准定义了NULL指针，表示不指向任何东西。
  和0值相同。但是在机器内部，NULL的实际值可能不是0.
  初始化指针最好用NULL。
  NULL指针不能间接访问，但在有的机器上NULL表示0地址，虽然没有变量被分配在0地址，但是还是有风险。
6.7 指针、间接访问和左值
  指针变量作为变量可以作为左值，接收新的值。
  间接访问表达式的结果作为左值。
  把整形数存储给一个指针变量，编译器会报警。
6.8 指针、间接访问和变量
  一个例子*&a=25；&a是指针类型常量。
  把25赋给变量a
6.9 指针常量
  对比这个句子*100 = 25；是错的，100是整形，间接访问操作只能用于指针类型表达式。
  如果确定要存入100 可以这样写*(int*)100 = 25;
  这个指针常量的唯一用处是用于访问硬件本身。例如，操作系统与输入输出设备控制器通信，在某些机器上，设备控制器的通信是通过某个特定内存地址读取和写入的（接口技术）。这些地址是预先知道的。
6.10 指针的指针
  用两个*定义的变量**p。
6.11 指针表达式
  能做左值的只有不是常量的，可以访问的，不是临时变量的。
6.12 实例
  库函数中存在的计算一个字符串长度的函数，指针指向的位置不为‘\0’长度就加1.
6.13 指针运算
  指针可以算术运算,加减一个整数，会根据指针类型调整整数，使指针刚好加一个相应类型字节数的位置。
  第二种是两个指针相减，只有当两个指针指向同一个数组中元素时才可以相减，结果类型是数组中元素长度，而不是两个地址的字节长度，是一个有符号整形类型（ptrdiff_t)。

  还可以进行关系运算：< <= > >= !=，前提是都指向同一个数组中元素。
  标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存位置的指针进行比较，但是不允许与指向数组第一个元素之前的那个内存位置的指针进行比较。
6.14 总结
  警告：
  1、错误地对一个未初始化的指针变量进行解引用
  2、错误地对一个NULL指针进行解引用
  3、向函数错误地传递NULL指针
  4、未检测到指针表达式的错误
  5、对一个指针进行减法运算，使它非法地指向了数组第一个元素前一个内存位置。

习题：
  3：
  void reverse_string(char *string)
  {
    char temp = 0;
    int i = 0,n=0;
    char *p = string;
    while(*p++)
    {
      n+=1;
    }
    p = string;
    for (;i<n/2; i++) {
      temp = *(p+i);
      *(p+i) = *(p+n-i-1);
      *(p+n-i-1)=temp;
    }
  }
