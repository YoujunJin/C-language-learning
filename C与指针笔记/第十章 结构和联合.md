第十章 结构和联合
数据以成组的形式存在，如姓名、年龄和工资应该存储在一起表示同一个人的信息，访问起来会简单一些。但是由于这些值的类型不同，无法存储在一个数组中，C中可以使用结构把不同类型的值存储在一起。
10.1 结构基础知识
  聚合数据类型（aggregate data type）能够同时存储超过一个的单独数据。C提供了两种数据类型，数组和结构。数组是相同类型的元素的集合，它的每个元素是通过下标引用或指针间接访问来选择的。
  结构也是一些值得集合，这些值称为它的成员。但一个结构得各个成员可能具有不同得类型。
  结构成员长度不一，所以不能用下标来访问，而是通过成员名字访问。
  也就是说结构变量在表达式中使用并不被替换成一个指针。

10.1.1 结构声明
  在声明结构时必须列出所包含得所有成员。这个列表包括每个成员得名字和类型。
  struct{
    int a;
    char b;
  } x;
  上面定义了一个结构体变量x，包含两个成员，但是省略了标签（tag）字段，所以下面得声明
  struct{
    int a;
    char b;
  } y;
  x和y变量不是一种类型，虽然成员都一样。
  标签允许多个声明使用同一个成员列表，并且创建同一种类型得结构。如下
  struct Simple{
    int a;
    char b;
  };
  声明了一个Simple结构标签，这个声明没有提供变量列表，但可以下一次用它来声明变量：
  struct Simple x；
  struct Simple y[2];
  声明结构时另一种良好的技巧是使用typedef 创建一个新的类型，如下：
  typedef struct{
    int a;
    char b;
  } Simple;
  这个技巧和声明一个结构标签的效果几乎相同，区别是Simple现在是个类型名而不是一个结构标签，所以后续声明变量时不需要带struct关键字了，因为Simple现在是一个类型。
10.1.2 结构成员
  任何类型的任何变量名字都可以作为结构的成员。
10.1.3 结构成员的直接访问
  结构变量的成员是通过点操作符（.)访问的。点操作符接收两个操作数，左操作数就是结构变量的名字，右操作数就是需要访问的成员名字。
  成员是结构的，也可以继续使用点操作符访问结构成员的结构成员。
10.1.4 结构成员的间接访问
  指向结构的指针，对指针执行间接访问操作可以获得这个结构，然后使用点操作符来访问它的成员。对于这样的指针，除了可以用括号提高优先级*p来获得这个结构后再用点操作符访问以外，还可以直接用箭头操作符->直接从指针间接访问成员变量。
10.1.5 结构的自引用
  在一个结构内部包含一个类型为该结构本身的成员的方法：
  不能是下面这种，因为self_ref1类型变量b还有下一个self_ref1类型变量，如此重复不会终止。
  struct self_ref1{
    int a;
    struct self_ref1 b;
  };
  而是用一个结构指针表示结构内部将有一个自己本身的结构类型，而指针的长度是固定的，因而结构的长度也固定，这才能编译成功。
  struct self_ref2{
    int a;
    struct self_ref2 * b;
  }
  上面这种结构常用于链表，树等高级数据结构。
  注意：typedef定义的新类型只有在其新类型名后面的分号结束后才会定义，如果像下面在结构内部使用则会发生未定义错误：
  typedef struct{
    int a;
    self_ref3 * b;
  } self_ref3;
  可以在typedef struct后面添加结构标签来声明b，如下:
  typedef struct self_ref3_tag{
    int a;
    self_ref3_tag b;
  } self_ref3;
  标签可以和类型名相同。
10.1.6 不完整的声明
  也就是可以先不声明结构的成员，只是声明了结构的标签，以后再声明其内部，主要是为了下面这种嵌套结构使用。
  struct B;
  struct A{
    struct B * partner;
    /*orther declaration*/
  }

  struct B{
    struct A * partner;
    /* orther declaration*/
  }
10.1.7 结构的初始化
  和数组的初始化很相似，一个位于一对花括号内部、由逗号分隔的初始值列表。
  按照顺序写出，如果初始列表的值不够，剩余的结构成员将使用缺省值初始化。
  结构中包含数组或结构成员，类似多维数组初始化，嵌套初始化列表。
10.2 结构、指针和成员
  指针可以保存一个结构的地址，指针+1如果在数组中表示是下一个结构，否则非法。可以用指针的间接访问访问数组元素或赋值。两种方式访问结构成员，指针->操作符，和点操作符，注意指针虽然值和第一个成员的地址相同，但是由于类型不同，不能用于表示第一个成员。
  如果要获得第一个成员的地址可以用强制类型转换或者更推荐用&取值。
10.3 结构的存储分配
  结构在内存中是如何实际存储的呢？
  编译器按照成员列表的顺序一个接一个地给每个成员分配内存。但是要注意有些类型需要满足正确的边界对齐要求，如某个机器要求起始存储位置必须能够被4整除，既包含整形又包含字符型变量的结构可能在字符变量和整形变量之间有填充空间，所以在需要考虑内存存储限制问题上要尽量把对边界要求严格的成员排在前面。
  如果要得知一个结构实际上的内存大小，可以使用sizeof函数
  如果要确定某个成员的实际位置，需要考虑边界对齐因素，可以使用offsetof宏（在stddef.h中）,offsetof(type,member)返回member在结构type距离起始位置偏移多少个字节。
10.4 作为函数参数的结构
  如果是用结构变量做参数，由于传值是拷贝一个新变量，对于结构类型效率很低，所以使用指针类型更好。
10.5 位段
  结构实现了位段（bit field）的能力，位段的声明和结构类似，但它的成员是一个或多个位的字段。这些不同长度的字段实际上存储于一个或多个整形变量中。
  位段声明必须声明为int、signed int或unsigned int类型。其次在成员名后面是一个冒号和一个整数，这个整数指定该位段所占用的位的数目。
  位段这个内容使结构可以直接访问到位，很多处理字节数据和系统操作的内容，感觉实际应该用不到。
10.6 联合
  union，联合的声明和结构类似，但它的行为方式却和结构不同。联合的所有成员引用的是内存中一个相同的位置，联合的大小取决于其最大的成员的大小。
  由成员的类型决定访问时的值是怎样的。
  一个可能比较有用的方法是声明一个联合类型变量，成员是各种不同类型的指针，存储都是一个指针大小，但是不用担心类型问题。

  初始化是花括号，但是这个初始值必须是联合的第一个成员的类型。否则也会转换（如果可能的话）。
10.7 总结
  结构，不同类型的值存储在一起；
  成员，通过名字访问；
  结构的声明，typedef；
  结构的成员可以是任何类型包括自身，但不能包含自身类型的结构变量；

习题
1：
struct phone_num{
  char qu[4];
  char ji[4];
  char zh[4];
}
struct record{
  int day;
  int month;
  int year;
  int second;
  int minute;
  int hour;
  struct phone_num num1;
  struct phone_num num2;
  struct phone_num num3;
}
